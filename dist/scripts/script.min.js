if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery");
}

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
    }
}(jQuery);

+function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

+function($) {
    "use strict";
    var dismiss = '[data-dismiss="alert"]';
    var Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.7";
    Alert.TRANSITION_DURATION = 150;
    Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = $(selector === "#" ? [] : selector);
        if (e) e.preventDefault();
        if (!$parent.length) {
            $parent = $this.closest(".alert");
        }
        $parent.trigger(e = $.Event("close.bs.alert"));
        if (e.isDefaultPrevented()) return;
        $parent.removeClass("in");
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.alert");
            if (!data) $this.data("bs.alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.alert;
    $.fn.alert = Plugin;
    $.fn.alert.Constructor = Alert;
    $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
    };
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery);

+function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.7";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state += "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d).prop(d, true);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d).prop(d, false);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked")) changed = false;
                $parent.find(".active").removeClass("active");
                this.$element.addClass("active");
            } else if ($input.prop("type") == "checkbox") {
                if ($input.prop("checked") !== this.$element.hasClass("active")) changed = false;
                this.$element.toggleClass("active");
            }
            $input.prop("checked", this.$element.hasClass("active"));
            if (changed) $input.trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
            this.$element.toggleClass("active");
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle");
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
            e.preventDefault();
            if ($btn.is("input,button")) $btn.trigger("focus"); else $btn.find("input:visible,button:visible").first().trigger("focus");
        }
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

+function($) {
    "use strict";
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find(".carousel-indicators");
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.7";
    Carousel.TRANSITION_DURATION = 600;
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: true,
        keyboard: true
    };
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();
            break;

          case 39:
            this.next();
            break;

          default:
            return;
        }
        e.preventDefault();
    };
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
    };
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children(".item");
        return this.$items.index(item || this.$active);
    };
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == "prev" ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    };
    Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (pos > this.$items.length - 1 || pos < 0) return;
        if (this.sliding) return this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        });
        if (activeIndex == pos) return this.pause().cycle();
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    };
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end);
            this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
    };
    Carousel.prototype.next = function() {
        if (this.sliding) return;
        return this.slide("next");
    };
    Carousel.prototype.prev = function() {
        if (this.sliding) return;
        return this.slide("prev");
    };
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active");
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == "next" ? "left" : "right";
        var that = this;
        if ($next.hasClass("active")) return this.sliding = false;
        var relatedTarget = $next[0];
        var slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active");
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass("active");
        }
        var slidEvent = $.Event("slid.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type);
            $next[0].offsetWidth;
            $active.addClass(direction);
            $next.addClass(direction);
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active");
                $active.removeClass([ "active", direction ].join(" "));
                that.sliding = false;
                setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
            $active.removeClass("active");
            $next.addClass("active");
            this.sliding = false;
            this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.carousel");
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option);
            var action = typeof option == "string" ? option : options.slide;
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
        });
    }
    var old = $.fn.carousel;
    $.fn.carousel = Plugin;
    $.fn.carousel.Constructor = Carousel;
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
    };
    var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if (!$target.hasClass("carousel")) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr("data-slide-to");
        if (slideIndex) options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex);
        }
        e.preventDefault();
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.7";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery);

+function($) {
    "use strict";
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.7";
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            if (e && e.type == "click" && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget));
        });
    }
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.disabled):visible a";
        var $items = $parent.find(".dropdown-menu" + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        if (e.which == 40 && index < $items.length - 1) index++;
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery);

+function($) {
    "use strict";
    var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find(".modal-dialog");
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
                this.$element.trigger("loaded.bs.modal");
            }, this));
        }
    };
    Modal.VERSION = "3.3.7";
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    };
    Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented()) return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass("modal-open");
        this.escape();
        this.resize();
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
            });
        });
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body);
            }
            that.$element.show().scrollTop(0);
            that.adjustDialog();
            if (transition) {
                that.$element[0].offsetWidth;
            }
            that.$element.addClass("in");
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        });
    };
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault();
        e = $.Event("hide.bs.modal");
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off("focusin.bs.modal");
        this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal");
        this.$dialog.off("mousedown.dismiss.bs.modal");
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus");
            }
        }, this));
    };
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
                e.which == 27 && this.hide();
            }, this));
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal");
        }
    };
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
        } else {
            $(window).off("resize.bs.modal");
        }
    };
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
            that.$body.removeClass("modal-open");
            that.resetAdjustments();
            that.resetScrollbar();
            that.$element.trigger("hidden.bs.modal");
        });
    };
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
    };
    Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body);
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false;
                    return;
                }
                if (e.target !== e.currentTarget) return;
                this.options.backdrop == "static" ? this.$element[0].focus() : this.hide();
            }, this));
            if (doAnimate) this.$backdrop[0].offsetWidth;
            this.$backdrop.addClass("in");
            if (!callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop();
                callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
            callback();
        }
    };
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    };
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    };
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    };
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
    };
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "";
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    };
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    };
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure";
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
    };
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.modal");
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("bs.modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
        });
    }
    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal;
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr("href");
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
        var option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        if ($this.is("a")) e.preventDefault();
        $target.one("show.bs.modal", function(showEvent) {
            if (showEvent.isDefaultPrevented()) return;
            $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        });
        Plugin.call($target, option, this);
    });
}(jQuery);

+function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.7";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = {
            click: false,
            hover: false,
            focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        }
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusin" ? "focus" : "hover"] = true;
        }
        if (self.tip().hasClass("in") || self.hoverState == "in") {
            self.hoverState = "in";
            return;
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true;
        }
        return false;
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusout" ? "focus" : "hover"] = false;
        }
        if (self.isInStateTrue()) return;
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var viewportDim = this.getPosition(this.$viewport);
                placement = placement == "bottom" && pos.bottom + actualHeight > viewportDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < viewportDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > viewportDim.width ? "left" : placement == "left" && pos.left - actualWidth < viewportDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            if (that.$element) {
                that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            }
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.right) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1e6); while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template);
            if (this.$tip.length != 1) {
                throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
            }
        }
        return this.$tip;
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        if (e) {
            self.inState.click = !self.inState.click;
            if (self.isInStateTrue()) self.enter(self); else self.leave(self);
        } else {
            self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
        }
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
            if (that.$tip) {
                that.$tip.detach();
            }
            that.$tip = null;
            that.$arrow = null;
            that.$viewport = null;
            that.$element = null;
        });
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || "") + " .nav li > a";
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this));
        this.refresh();
        this.process();
    }
    ScrollSpy.VERSION = "3.3.7";
    ScrollSpy.DEFAULTS = {
        offset: 10
    };
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    };
    ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = "offset";
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position";
            offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
            var $el = $(this);
            var href = $el.data("target") || $el.attr("href");
            var $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]);
            that.targets.push(this[1]);
        });
    };
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
            this.refresh();
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null;
            return this.clear();
        }
        for (i = offsets.length; i--; ) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
    };
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents("li").addClass("active");
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active");
        }
        active.trigger("activate.bs.scrollspy");
    };
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.scrollspy");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin;
    $.fn.scrollspy.Constructor = ScrollSpy;
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
    };
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

+function($) {
    "use strict";
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.7";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

(function($, window, document, undefined) {
    $("input.styled-inputfile").each(function() {
        var $input = $(this), $label = $input.next("label"), labelVal = $label.html();
        $input.on("change", function(e) {
            var fileName = "";
            if (this.files && this.files.length > 1) fileName = (this.getAttribute("data-multiple-caption") || "").replace("{count}", this.files.length); else if (e.target.value) fileName = e.target.value.split("\\").pop();
            if (fileName) $label.find("span").html(fileName); else $label.html(labelVal);
        });
        $input.on("focus", function() {
            $input.addClass("has-focus");
        }).on("blur", function() {
            $input.removeClass("has-focus");
        });
    });
})(jQuery, window, document);

(function(window) {
    if (!window.document) return;
    var document = window.document;
    if (!document.querySelectorAll) {
        document.querySelectorAll = function(selectors) {
            var style = document.createElement("style"), elements = [], element;
            document.documentElement.firstChild.appendChild(style);
            document._qsa = [];
            style.styleSheet.cssText = selectors + "{x-qsa:expression(document._qsa && document._qsa.push(this))}";
            window.scrollBy(0, 0);
            style.parentNode.removeChild(style);
            while (document._qsa.length) {
                element = document._qsa.shift();
                element.style.removeAttribute("x-qsa");
                elements.push(element);
            }
            document._qsa = null;
            return elements;
        };
    }
    if (!document.querySelector) {
        document.querySelector = function(selectors) {
            var elements = document.querySelectorAll(selectors);
            return elements.length ? elements[0] : null;
        };
    }
    if (!document.getElementsByClassName) {
        document.getElementsByClassName = function(classNames) {
            classNames = String(classNames).replace(/^|\s+/g, ".");
            return document.querySelectorAll(classNames);
        };
    }
    if (!Object.keys) {
        Object.keys = function(o) {
            if (o !== Object(o)) {
                throw TypeError("Object.keys called on non-object");
            }
            var ret = [], p;
            for (p in o) {
                if (Object.prototype.hasOwnProperty.call(o, p)) {
                    ret.push(p);
                }
            }
            return ret;
        };
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
            if (this === void 0 || this === null) {
                throw TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function") {
                throw TypeError();
            }
            var thisp = arguments[1], i;
            for (i = 0; i < len; i++) {
                if (i in t) {
                    fun.call(thisp, t[i], i, t);
                }
            }
        };
    }
    (function(global) {
        var B64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        global.atob = global.atob || function(input) {
            input = String(input);
            var position = 0, output = [], buffer = 0, bits = 0, n;
            input = input.replace(/\s/g, "");
            if (input.length % 4 === 0) {
                input = input.replace(/=+$/, "");
            }
            if (input.length % 4 === 1) {
                throw Error("InvalidCharacterError");
            }
            if (/[^+\/0-9A-Za-z]/.test(input)) {
                throw Error("InvalidCharacterError");
            }
            while (position < input.length) {
                n = B64_ALPHABET.indexOf(input.charAt(position));
                buffer = buffer << 6 | n;
                bits += 6;
                if (bits === 24) {
                    output.push(String.fromCharCode(buffer >> 16 & 255));
                    output.push(String.fromCharCode(buffer >> 8 & 255));
                    output.push(String.fromCharCode(buffer & 255));
                    bits = 0;
                    buffer = 0;
                }
                position += 1;
            }
            if (bits === 12) {
                buffer = buffer >> 4;
                output.push(String.fromCharCode(buffer & 255));
            } else if (bits === 18) {
                buffer = buffer >> 2;
                output.push(String.fromCharCode(buffer >> 8 & 255));
                output.push(String.fromCharCode(buffer & 255));
            }
            return output.join("");
        };
        global.btoa = global.btoa || function(input) {
            input = String(input);
            var position = 0, out = [], o1, o2, o3, e1, e2, e3, e4;
            if (/[^\x00-\xFF]/.test(input)) {
                throw Error("InvalidCharacterError");
            }
            while (position < input.length) {
                o1 = input.charCodeAt(position++);
                o2 = input.charCodeAt(position++);
                o3 = input.charCodeAt(position++);
                e1 = o1 >> 2;
                e2 = (o1 & 3) << 4 | o2 >> 4;
                e3 = (o2 & 15) << 2 | o3 >> 6;
                e4 = o3 & 63;
                if (position === input.length + 2) {
                    e3 = 64;
                    e4 = 64;
                } else if (position === input.length + 1) {
                    e4 = 64;
                }
                out.push(B64_ALPHABET.charAt(e1), B64_ALPHABET.charAt(e2), B64_ALPHABET.charAt(e3), B64_ALPHABET.charAt(e4));
            }
            return out.join("");
        };
    })(window);
    if (!Object.prototype.hasOwnProperty) {
        Object.prototype.hasOwnProperty = function(prop) {
            var proto = this.__proto__ || this.constructor.prototype;
            return prop in this && (!(prop in proto) || proto[prop] !== this[prop]);
        };
    }
    (function() {
        if ("performance" in window === false) {
            window.performance = {};
        }
        Date.now = Date.now || function() {
            return new Date().getTime();
        };
        if ("now" in window.performance === false) {
            var nowOffset = Date.now();
            if (performance.timing && performance.timing.navigationStart) {
                nowOffset = performance.timing.navigationStart;
            }
            window.performance.now = function now() {
                return Date.now() - nowOffset;
            };
        }
    })();
    if (!window.requestAnimationFrame) {
        if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {
            (function(global) {
                global.requestAnimationFrame = function(callback) {
                    return webkitRequestAnimationFrame(function() {
                        callback(global.performance.now());
                    });
                };
                global.cancelAnimationFrame = global.webkitCancelAnimationFrame;
            })(window);
        } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {
            (function(global) {
                global.requestAnimationFrame = function(callback) {
                    return mozRequestAnimationFrame(function() {
                        callback(global.performance.now());
                    });
                };
                global.cancelAnimationFrame = global.mozCancelAnimationFrame;
            })(window);
        } else {
            (function(global) {
                global.requestAnimationFrame = function(callback) {
                    return global.setTimeout(callback, 1e3 / 60);
                };
                global.cancelAnimationFrame = global.clearTimeout;
            })(window);
        }
    }
})(this);

(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object") module.exports = factory(); else if (typeof define === "function" && define.amd) define([], factory); else if (typeof exports === "object") exports["Holder"] = factory(); else root["Holder"] = factory();
})(this, function() {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(1);
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            var onDomReady = __webpack_require__(2);
            var querystring = __webpack_require__(3);
            var SceneGraph = __webpack_require__(6);
            var utils = __webpack_require__(7);
            var SVG = __webpack_require__(8);
            var DOM = __webpack_require__(9);
            var Color = __webpack_require__(10);
            var constants = __webpack_require__(11);
            var svgRenderer = __webpack_require__(12);
            var sgCanvasRenderer = __webpack_require__(15);
            var extend = utils.extend;
            var dimensionCheck = utils.dimensionCheck;
            var SVG_NS = constants.svg_ns;
            var Holder = {
                version: constants.version,
                addTheme: function(name, theme) {
                    name != null && theme != null && (App.settings.themes[name] = theme);
                    delete App.vars.cache.themeKeys;
                    return this;
                },
                addImage: function(src, el) {
                    var nodes = DOM.getNodeArray(el);
                    nodes.forEach(function(node) {
                        var img = DOM.newEl("img");
                        var domProps = {};
                        domProps[App.setup.dataAttr] = src;
                        DOM.setAttr(img, domProps);
                        node.appendChild(img);
                    });
                    return this;
                },
                setResizeUpdate: function(el, value) {
                    if (el.holderData) {
                        el.holderData.resizeUpdate = !!value;
                        if (el.holderData.resizeUpdate) {
                            updateResizableElements(el);
                        }
                    }
                },
                run: function(userOptions) {
                    userOptions = userOptions || {};
                    var engineSettings = {};
                    var options = extend(App.settings, userOptions);
                    App.vars.preempted = true;
                    App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;
                    engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;
                    if (App.setup.renderers.join(",").indexOf(engineSettings.renderer) === -1) {
                        engineSettings.renderer = App.setup.supportsSVG ? "svg" : App.setup.supportsCanvas ? "canvas" : "html";
                    }
                    var images = DOM.getNodeArray(options.images);
                    var bgnodes = DOM.getNodeArray(options.bgnodes);
                    var stylenodes = DOM.getNodeArray(options.stylenodes);
                    var objects = DOM.getNodeArray(options.objects);
                    engineSettings.stylesheets = [];
                    engineSettings.svgXMLStylesheet = true;
                    engineSettings.noFontFallback = !!options.noFontFallback;
                    engineSettings.noBackgroundSize = !!options.noBackgroundSize;
                    stylenodes.forEach(function(styleNode) {
                        if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == "stylesheet") {
                            var href = styleNode.attributes.href.value;
                            var proxyLink = DOM.newEl("a");
                            proxyLink.href = href;
                            var stylesheetURL = proxyLink.protocol + "//" + proxyLink.host + proxyLink.pathname + proxyLink.search;
                            engineSettings.stylesheets.push(stylesheetURL);
                        }
                    });
                    bgnodes.forEach(function(bgNode) {
                        if (!global.getComputedStyle) return;
                        var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue("background-image");
                        var dataBackgroundImage = bgNode.getAttribute("data-background-src");
                        var rawURL = dataBackgroundImage || backgroundImage;
                        var holderURL = null;
                        var holderString = options.domain + "/";
                        var holderStringIndex = rawURL.indexOf(holderString);
                        if (holderStringIndex === 0) {
                            holderURL = rawURL;
                        } else if (holderStringIndex === 1 && rawURL[0] === "?") {
                            holderURL = rawURL.slice(1);
                        } else {
                            var fragment = rawURL.substr(holderStringIndex).match(/([^\"]*)"?\)/);
                            if (fragment !== null) {
                                holderURL = fragment[1];
                            } else if (rawURL.indexOf("url(") === 0) {
                                throw "Holder: unable to parse background URL: " + rawURL;
                            }
                        }
                        if (holderURL) {
                            var holderFlags = parseURL(holderURL, options);
                            if (holderFlags) {
                                prepareDOMElement({
                                    mode: "background",
                                    el: bgNode,
                                    flags: holderFlags,
                                    engineSettings: engineSettings
                                });
                            }
                        }
                    });
                    objects.forEach(function(object) {
                        var objectAttr = {};
                        try {
                            objectAttr.data = object.getAttribute("data");
                            objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);
                        } catch (e) {}
                        var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;
                        var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;
                        if (objectHasSrcURL) {
                            prepareImageElement(options, engineSettings, objectAttr.data, object);
                        } else if (objectHasDataSrcURL) {
                            prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);
                        }
                    });
                    images.forEach(function(image) {
                        var imageAttr = {};
                        try {
                            imageAttr.src = image.getAttribute("src");
                            imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);
                            imageAttr.rendered = image.getAttribute("data-holder-rendered");
                        } catch (e) {}
                        var imageHasSrc = imageAttr.src != null;
                        var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;
                        var imageRendered = imageAttr.rendered != null && imageAttr.rendered == "true";
                        if (imageHasSrc) {
                            if (imageAttr.src.indexOf(options.domain) === 0) {
                                prepareImageElement(options, engineSettings, imageAttr.src, image);
                            } else if (imageHasDataSrcURL) {
                                if (imageRendered) {
                                    prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                                } else {
                                    (function(src, options, engineSettings, dataSrc, image) {
                                        utils.imageExists(src, function(exists) {
                                            if (!exists) {
                                                prepareImageElement(options, engineSettings, dataSrc, image);
                                            }
                                        });
                                    })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);
                                }
                            }
                        } else if (imageHasDataSrcURL) {
                            prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                        }
                    });
                    return this;
                }
            };
            var App = {
                settings: {
                    domain: "holder.js",
                    images: "img",
                    objects: "object",
                    bgnodes: "body .holderjs",
                    stylenodes: "head link.holderjs",
                    themes: {
                        gray: {
                            bg: "#EEEEEE",
                            fg: "#AAAAAA"
                        },
                        social: {
                            bg: "#3a5a97",
                            fg: "#FFFFFF"
                        },
                        industrial: {
                            bg: "#434A52",
                            fg: "#C2F200"
                        },
                        sky: {
                            bg: "#0D8FDB",
                            fg: "#FFFFFF"
                        },
                        vine: {
                            bg: "#39DBAC",
                            fg: "#1E292C"
                        },
                        lava: {
                            bg: "#F8591A",
                            fg: "#1C2846"
                        }
                    }
                },
                defaults: {
                    size: 10,
                    units: "pt",
                    scale: 1 / 16
                }
            };
            function prepareImageElement(options, engineSettings, src, el) {
                var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);
                if (holderFlags) {
                    prepareDOMElement({
                        mode: null,
                        el: el,
                        flags: holderFlags,
                        engineSettings: engineSettings
                    });
                }
            }
            function parseURL(url, instanceOptions) {
                var holder = {
                    theme: extend(App.settings.themes.gray, null),
                    stylesheets: instanceOptions.stylesheets,
                    instanceOptions: instanceOptions
                };
                var firstQuestionMark = url.indexOf("?");
                var parts = [ url ];
                if (firstQuestionMark !== -1) {
                    parts = [ url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1) ];
                }
                var basics = parts[0].split("/");
                holder.holderURL = url;
                var dimensions = basics[1];
                var dimensionData = dimensions.match(/([\d]+p?)x([\d]+p?)/);
                if (!dimensionData) return false;
                holder.fluid = dimensions.indexOf("p") !== -1;
                holder.dimensions = {
                    width: dimensionData[1].replace("p", "%"),
                    height: dimensionData[2].replace("p", "%")
                };
                if (parts.length === 2) {
                    var options = querystring.parse(parts[1]);
                    if (utils.truthy(options.ratio)) {
                        holder.fluid = true;
                        var ratioWidth = parseFloat(holder.dimensions.width.replace("%", ""));
                        var ratioHeight = parseFloat(holder.dimensions.height.replace("%", ""));
                        ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));
                        ratioWidth = 100;
                        holder.dimensions.width = ratioWidth + "%";
                        holder.dimensions.height = ratioHeight + "%";
                    }
                    holder.auto = utils.truthy(options.auto);
                    if (options.bg) {
                        holder.theme.bg = utils.parseColor(options.bg);
                    }
                    if (options.fg) {
                        holder.theme.fg = utils.parseColor(options.fg);
                    }
                    if (options.bg && !options.fg) {
                        holder.autoFg = true;
                    }
                    if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {
                        holder.theme = extend(holder.instanceOptions.themes[options.theme], null);
                    }
                    if (options.text) {
                        holder.text = options.text;
                    }
                    if (options.textmode) {
                        holder.textmode = options.textmode;
                    }
                    if (options.size) {
                        holder.size = options.size;
                    }
                    if (options.font) {
                        holder.font = options.font;
                    }
                    if (options.align) {
                        holder.align = options.align;
                    }
                    if (options.lineWrap) {
                        holder.lineWrap = options.lineWrap;
                    }
                    holder.nowrap = utils.truthy(options.nowrap);
                    holder.outline = utils.truthy(options.outline);
                    if (utils.truthy(options.random)) {
                        App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);
                        var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
                        holder.theme = extend(holder.instanceOptions.themes[_theme], null);
                    }
                }
                return holder;
            }
            function prepareDOMElement(prepSettings) {
                var mode = prepSettings.mode;
                var el = prepSettings.el;
                var flags = prepSettings.flags;
                var _engineSettings = prepSettings.engineSettings;
                var dimensions = flags.dimensions, theme = flags.theme;
                var dimensionsCaption = dimensions.width + "x" + dimensions.height;
                mode = mode == null ? flags.fluid ? "fluid" : "image" : mode;
                var holderTemplateRe = /holder_([a-z]+)/g;
                var dimensionsInText = false;
                if (flags.text != null) {
                    theme.text = flags.text;
                    if (el.nodeName.toLowerCase() === "object") {
                        var textLines = theme.text.split("\\n");
                        for (var k = 0; k < textLines.length; k++) {
                            textLines[k] = utils.encodeHtmlEntity(textLines[k]);
                        }
                        theme.text = textLines.join("\\n");
                    }
                }
                if (theme.text) {
                    var holderTemplateMatches = theme.text.match(holderTemplateRe);
                    if (holderTemplateMatches !== null) {
                        holderTemplateMatches.forEach(function(match) {
                            if (match === "holder_dimensions") {
                                theme.text = theme.text.replace(match, dimensionsCaption);
                            }
                        });
                    }
                }
                var holderURL = flags.holderURL;
                var engineSettings = extend(_engineSettings, null);
                if (flags.font) {
                    theme.font = flags.font;
                    if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === "img" && App.setup.supportsCanvas && engineSettings.renderer === "svg") {
                        engineSettings = extend(engineSettings, {
                            renderer: "canvas"
                        });
                    }
                }
                if (flags.font && engineSettings.renderer == "canvas") {
                    engineSettings.reRender = true;
                }
                if (mode == "background") {
                    if (el.getAttribute("data-background-src") == null) {
                        DOM.setAttr(el, {
                            "data-background-src": holderURL
                        });
                    }
                } else {
                    var domProps = {};
                    domProps[App.vars.dataAttr] = holderURL;
                    DOM.setAttr(el, domProps);
                }
                flags.theme = theme;
                el.holderData = {
                    flags: flags,
                    engineSettings: engineSettings
                };
                if (mode == "image" || mode == "fluid") {
                    DOM.setAttr(el, {
                        alt: theme.text ? dimensionsInText ? theme.text : theme.text + " [" + dimensionsCaption + "]" : dimensionsCaption
                    });
                }
                var renderSettings = {
                    mode: mode,
                    el: el,
                    holderSettings: {
                        dimensions: dimensions,
                        theme: theme,
                        flags: flags
                    },
                    engineSettings: engineSettings
                };
                if (mode == "image") {
                    if (!flags.auto) {
                        el.style.width = dimensions.width + "px";
                        el.style.height = dimensions.height + "px";
                    }
                    if (engineSettings.renderer == "html") {
                        el.style.backgroundColor = theme.bg;
                    } else {
                        render(renderSettings);
                        if (flags.textmode == "exact") {
                            el.holderData.resizeUpdate = true;
                            App.vars.resizableImages.push(el);
                            updateResizableElements(el);
                        }
                    }
                } else if (mode == "background" && engineSettings.renderer != "html") {
                    render(renderSettings);
                } else if (mode == "fluid") {
                    el.holderData.resizeUpdate = true;
                    if (dimensions.height.slice(-1) == "%") {
                        el.style.height = dimensions.height;
                    } else if (flags.auto == null || !flags.auto) {
                        el.style.height = dimensions.height + "px";
                    }
                    if (dimensions.width.slice(-1) == "%") {
                        el.style.width = dimensions.width;
                    } else if (flags.auto == null || !flags.auto) {
                        el.style.width = dimensions.width + "px";
                    }
                    if (el.style.display == "inline" || el.style.display === "" || el.style.display == "none") {
                        el.style.display = "block";
                    }
                    setInitialDimensions(el);
                    if (engineSettings.renderer == "html") {
                        el.style.backgroundColor = theme.bg;
                    } else {
                        App.vars.resizableImages.push(el);
                        updateResizableElements(el);
                    }
                }
            }
            function render(renderSettings) {
                var image = null;
                var mode = renderSettings.mode;
                var el = renderSettings.el;
                var holderSettings = renderSettings.holderSettings;
                var engineSettings = renderSettings.engineSettings;
                switch (engineSettings.renderer) {
                  case "svg":
                    if (!App.setup.supportsSVG) return;
                    break;

                  case "canvas":
                    if (!App.setup.supportsCanvas) return;
                    break;

                  default:
                    return;
                }
                var scene = {
                    width: holderSettings.dimensions.width,
                    height: holderSettings.dimensions.height,
                    theme: holderSettings.theme,
                    flags: holderSettings.flags
                };
                var sceneGraph = buildSceneGraph(scene);
                function getRenderedImage() {
                    var image = null;
                    switch (engineSettings.renderer) {
                      case "canvas":
                        image = sgCanvasRenderer(sceneGraph, renderSettings);
                        break;

                      case "svg":
                        image = svgRenderer(sceneGraph, renderSettings);
                        break;

                      default:
                        throw "Holder: invalid renderer: " + engineSettings.renderer;
                    }
                    return image;
                }
                image = getRenderedImage();
                if (image == null) {
                    throw "Holder: couldn't render placeholder";
                }
                if (mode == "background") {
                    el.style.backgroundImage = "url(" + image + ")";
                    if (!engineSettings.noBackgroundSize) {
                        el.style.backgroundSize = scene.width + "px " + scene.height + "px";
                    }
                } else {
                    if (el.nodeName.toLowerCase() === "img") {
                        DOM.setAttr(el, {
                            src: image
                        });
                    } else if (el.nodeName.toLowerCase() === "object") {
                        DOM.setAttr(el, {
                            data: image,
                            type: "image/svg+xml"
                        });
                    }
                    if (engineSettings.reRender) {
                        global.setTimeout(function() {
                            var image = getRenderedImage();
                            if (image == null) {
                                throw "Holder: couldn't render placeholder";
                            }
                            if (el.nodeName.toLowerCase() === "img") {
                                DOM.setAttr(el, {
                                    src: image
                                });
                            } else if (el.nodeName.toLowerCase() === "object") {
                                DOM.setAttr(el, {
                                    data: image,
                                    type: "image/svg+xml"
                                });
                            }
                        }, 150);
                    }
                }
                DOM.setAttr(el, {
                    "data-holder-rendered": true
                });
            }
            function buildSceneGraph(scene) {
                var fontSize = App.defaults.size;
                if (parseFloat(scene.theme.size)) {
                    fontSize = scene.theme.size;
                } else if (parseFloat(scene.flags.size)) {
                    fontSize = scene.flags.size;
                }
                scene.font = {
                    family: scene.theme.font ? scene.theme.font : "Arial, Helvetica, Open Sans, sans-serif",
                    size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),
                    units: scene.theme.units ? scene.theme.units : App.defaults.units,
                    weight: scene.theme.fontweight ? scene.theme.fontweight : "bold"
                };
                scene.text = scene.theme.text || Math.floor(scene.width) + "x" + Math.floor(scene.height);
                scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;
                scene.align = scene.theme.align || scene.flags.align || "center";
                switch (scene.flags.textmode) {
                  case "literal":
                    scene.text = scene.flags.dimensions.width + "x" + scene.flags.dimensions.height;
                    break;

                  case "exact":
                    if (!scene.flags.exactDimensions) break;
                    scene.text = Math.floor(scene.flags.exactDimensions.width) + "x" + Math.floor(scene.flags.exactDimensions.height);
                    break;
                }
                var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;
                var sceneMargin = scene.width * lineWrap;
                var maxLineWidth = sceneMargin;
                var sceneGraph = new SceneGraph({
                    width: scene.width,
                    height: scene.height
                });
                var Shape = sceneGraph.Shape;
                var holderBg = new Shape.Rect("holderBg", {
                    fill: scene.theme.bg
                });
                holderBg.resize(scene.width, scene.height);
                sceneGraph.root.add(holderBg);
                if (scene.flags.outline) {
                    var outlineColor = new Color(holderBg.properties.fill);
                    outlineColor = outlineColor.lighten(outlineColor.lighterThan("7f7f7f") ? -.1 : .1);
                    holderBg.properties.outline = {
                        fill: outlineColor.toHex(true),
                        width: 2
                    };
                }
                var holderTextColor = scene.theme.fg;
                if (scene.flags.autoFg) {
                    var holderBgColor = new Color(holderBg.properties.fill);
                    var lightColor = new Color("fff");
                    var darkColor = new Color("000", {
                        alpha: .285714
                    });
                    holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan("7f7f7f") ? darkColor : lightColor).toHex(true);
                }
                var holderTextGroup = new Shape.Group("holderTextGroup", {
                    text: scene.text,
                    align: scene.align,
                    font: scene.font,
                    fill: holderTextColor
                });
                holderTextGroup.moveTo(null, null, 1);
                sceneGraph.root.add(holderTextGroup);
                var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);
                if (!tpdata) {
                    throw "Holder: staging fallback not supported yet.";
                }
                holderTextGroup.properties.leading = tpdata.boundingBox.height;
                var textNode = null;
                var line = null;
                function finalizeLine(parent, line, width, height) {
                    line.width = width;
                    line.height = height;
                    parent.width = Math.max(parent.width, line.width);
                    parent.height += line.height;
                }
                if (tpdata.lineCount > 1) {
                    var offsetX = 0;
                    var offsetY = 0;
                    var lineIndex = 0;
                    var lineKey;
                    line = new Shape.Group("line" + lineIndex);
                    if (scene.align === "left" || scene.align === "right") {
                        maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);
                    }
                    for (var i = 0; i < tpdata.words.length; i++) {
                        var word = tpdata.words[i];
                        textNode = new Shape.Text(word.text);
                        var newline = word.text == "\\n";
                        if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {
                            finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                            holderTextGroup.add(line);
                            offsetX = 0;
                            offsetY += holderTextGroup.properties.leading;
                            lineIndex += 1;
                            line = new Shape.Group("line" + lineIndex);
                            line.y = offsetY;
                        }
                        if (newline === true) {
                            continue;
                        }
                        textNode.moveTo(offsetX, 0);
                        offsetX += tpdata.spaceWidth + word.width;
                        line.add(textNode);
                    }
                    finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                    holderTextGroup.add(line);
                    if (scene.align === "left") {
                        holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
                    } else if (scene.align === "right") {
                        for (lineKey in holderTextGroup.children) {
                            line = holderTextGroup.children[lineKey];
                            line.moveTo(scene.width - line.width, null, null);
                        }
                        holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
                    } else {
                        for (lineKey in holderTextGroup.children) {
                            line = holderTextGroup.children[lineKey];
                            line.moveTo((holderTextGroup.width - line.width) / 2, null, null);
                        }
                        holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);
                    }
                    holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);
                    if ((scene.height - holderTextGroup.height) / 2 < 0) {
                        holderTextGroup.moveTo(null, 0, null);
                    }
                } else {
                    textNode = new Shape.Text(scene.text);
                    line = new Shape.Group("line0");
                    line.add(textNode);
                    holderTextGroup.add(line);
                    if (scene.align === "left") {
                        holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
                    } else if (scene.align === "right") {
                        holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
                    } else {
                        holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);
                    }
                    holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);
                }
                return sceneGraph;
            }
            function textSize(width, height, fontSize, scale) {
                var stageWidth = parseInt(width, 10);
                var stageHeight = parseInt(height, 10);
                var bigSide = Math.max(stageWidth, stageHeight);
                var smallSide = Math.min(stageWidth, stageHeight);
                var newHeight = .8 * Math.min(smallSide, bigSide * scale);
                return Math.round(Math.max(fontSize, newHeight));
            }
            function updateResizableElements(element) {
                var images;
                if (element == null || element.nodeType == null) {
                    images = App.vars.resizableImages;
                } else {
                    images = [ element ];
                }
                for (var i = 0, l = images.length; i < l; i++) {
                    var el = images[i];
                    if (el.holderData) {
                        var flags = el.holderData.flags;
                        var dimensions = dimensionCheck(el);
                        if (dimensions) {
                            if (!el.holderData.resizeUpdate) {
                                continue;
                            }
                            if (flags.fluid && flags.auto) {
                                var fluidConfig = el.holderData.fluidConfig;
                                switch (fluidConfig.mode) {
                                  case "width":
                                    dimensions.height = dimensions.width / fluidConfig.ratio;
                                    break;

                                  case "height":
                                    dimensions.width = dimensions.height * fluidConfig.ratio;
                                    break;
                                }
                            }
                            var settings = {
                                mode: "image",
                                holderSettings: {
                                    dimensions: dimensions,
                                    theme: flags.theme,
                                    flags: flags
                                },
                                el: el,
                                engineSettings: el.holderData.engineSettings
                            };
                            if (flags.textmode == "exact") {
                                flags.exactDimensions = dimensions;
                                settings.holderSettings.dimensions = flags.dimensions;
                            }
                            render(settings);
                        } else {
                            setInvisible(el);
                        }
                    }
                }
            }
            function setInitialDimensions(el) {
                if (el.holderData) {
                    var dimensions = dimensionCheck(el);
                    if (dimensions) {
                        var flags = el.holderData.flags;
                        var fluidConfig = {
                            fluidHeight: flags.dimensions.height.slice(-1) == "%",
                            fluidWidth: flags.dimensions.width.slice(-1) == "%",
                            mode: null,
                            initialDimensions: dimensions
                        };
                        if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {
                            fluidConfig.mode = "width";
                            fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
                        } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {
                            fluidConfig.mode = "height";
                            fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
                        }
                        el.holderData.fluidConfig = fluidConfig;
                    } else {
                        setInvisible(el);
                    }
                }
            }
            function visibilityCheck() {
                var renderableImages = [];
                var keys = Object.keys(App.vars.invisibleImages);
                var el;
                keys.forEach(function(key) {
                    el = App.vars.invisibleImages[key];
                    if (dimensionCheck(el) && el.nodeName.toLowerCase() == "img") {
                        renderableImages.push(el);
                        delete App.vars.invisibleImages[key];
                    }
                });
                if (renderableImages.length) {
                    Holder.run({
                        images: renderableImages
                    });
                }
                setTimeout(function() {
                    global.requestAnimationFrame(visibilityCheck);
                }, 10);
            }
            function startVisibilityCheck() {
                if (!App.vars.visibilityCheckStarted) {
                    global.requestAnimationFrame(visibilityCheck);
                    App.vars.visibilityCheckStarted = true;
                }
            }
            function setInvisible(el) {
                if (!el.holderData.invisibleId) {
                    App.vars.invisibleId += 1;
                    App.vars.invisibleImages["i" + App.vars.invisibleId] = el;
                    el.holderData.invisibleId = App.vars.invisibleId;
                }
            }
            var stagingRenderer = function() {
                var svg = null, stagingText = null, stagingTextNode = null;
                return function(graph) {
                    var rootNode = graph.root;
                    if (App.setup.supportsSVG) {
                        var firstTimeSetup = false;
                        var tnode = function(text) {
                            return document.createTextNode(text);
                        };
                        if (svg == null || svg.parentNode !== document.body) {
                            firstTimeSetup = true;
                        }
                        svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);
                        svg.style.display = "block";
                        if (firstTimeSetup) {
                            stagingText = DOM.newEl("text", SVG_NS);
                            stagingTextNode = tnode(null);
                            DOM.setAttr(stagingText, {
                                x: 0
                            });
                            stagingText.appendChild(stagingTextNode);
                            svg.appendChild(stagingText);
                            document.body.appendChild(svg);
                            svg.style.visibility = "hidden";
                            svg.style.position = "absolute";
                            svg.style.top = "-100%";
                            svg.style.left = "-100%";
                        }
                        var holderTextGroup = rootNode.children.holderTextGroup;
                        var htgProps = holderTextGroup.properties;
                        DOM.setAttr(stagingText, {
                            y: htgProps.font.size,
                            style: utils.cssProps({
                                "font-weight": htgProps.font.weight,
                                "font-size": htgProps.font.size + htgProps.font.units,
                                "font-family": htgProps.font.family
                            })
                        });
                        stagingTextNode.nodeValue = htgProps.text;
                        var stagingTextBBox = stagingText.getBBox();
                        var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);
                        var words = htgProps.text.split(" ");
                        var newlines = htgProps.text.match(/\\n/g);
                        lineCount += newlines == null ? 0 : newlines.length;
                        stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, "");
                        var computedNoSpaceLength = stagingText.getComputedTextLength();
                        var diffLength = stagingTextBBox.width - computedNoSpaceLength;
                        var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));
                        var wordWidths = [];
                        if (lineCount > 1) {
                            stagingTextNode.nodeValue = "";
                            for (var i = 0; i < words.length; i++) {
                                if (words[i].length === 0) continue;
                                stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);
                                var bbox = stagingText.getBBox();
                                wordWidths.push({
                                    text: words[i],
                                    width: bbox.width
                                });
                            }
                        }
                        svg.style.display = "none";
                        return {
                            spaceWidth: spaceWidth,
                            lineCount: lineCount,
                            boundingBox: stagingTextBBox,
                            words: wordWidths
                        };
                    } else {
                        return false;
                    }
                };
            }();
            function debounce(fn) {
                if (!App.vars.debounceTimer) fn.call(this);
                if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);
                App.vars.debounceTimer = global.setTimeout(function() {
                    App.vars.debounceTimer = null;
                    fn.call(this);
                }, App.setup.debounce);
            }
            function resizeEvent() {
                debounce(function() {
                    updateResizableElements(null);
                });
            }
            for (var flag in App.flags) {
                if (!App.flags.hasOwnProperty(flag)) continue;
                App.flags[flag].match = function(val) {
                    return val.match(this.regex);
                };
            }
            App.setup = {
                renderer: "html",
                debounce: 100,
                ratio: 1,
                supportsCanvas: false,
                supportsSVG: false,
                lineWrapRatio: .9,
                dataAttr: "data-src",
                renderers: [ "html", "canvas", "svg" ]
            };
            App.vars = {
                preempted: false,
                resizableImages: [],
                invisibleImages: {},
                invisibleId: 0,
                visibilityCheckStarted: false,
                debounceTimer: null,
                cache: {}
            };
            (function() {
                var canvas = DOM.newEl("canvas");
                if (canvas.getContext) {
                    if (canvas.toDataURL("image/png").indexOf("data:image/png") != -1) {
                        App.setup.renderer = "canvas";
                        App.setup.supportsCanvas = true;
                    }
                }
                if (!!document.createElementNS && !!document.createElementNS(SVG_NS, "svg").createSVGRect) {
                    App.setup.renderer = "svg";
                    App.setup.supportsSVG = true;
                }
            })();
            startVisibilityCheck();
            if (onDomReady) {
                onDomReady(function() {
                    if (!App.vars.preempted) {
                        Holder.run();
                    }
                    if (global.addEventListener) {
                        global.addEventListener("resize", resizeEvent, false);
                        global.addEventListener("orientationchange", resizeEvent, false);
                    } else {
                        global.attachEvent("onresize", resizeEvent);
                    }
                    if (typeof global.Turbolinks == "object") {
                        global.document.addEventListener("page:change", function() {
                            Holder.run();
                        });
                    }
                });
            }
            module.exports = Holder;
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        function _onDomReady(win) {
            if (document.readyState == null && document.addEventListener) {
                document.addEventListener("DOMContentLoaded", function DOMContentLoaded() {
                    document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                    document.readyState = "complete";
                }, false);
                document.readyState = "loading";
            }
            var doc = win.document, docElem = doc.documentElement, LOAD = "load", FALSE = false, ONLOAD = "on" + LOAD, COMPLETE = "complete", READYSTATE = "readyState", ATTACHEVENT = "attachEvent", DETACHEVENT = "detachEvent", ADDEVENTLISTENER = "addEventListener", DOMCONTENTLOADED = "DOMContentLoaded", ONREADYSTATECHANGE = "onreadystatechange", REMOVEEVENTLISTENER = "removeEventListener", w3c = ADDEVENTLISTENER in doc, _top = FALSE, isReady = FALSE, callbacks = [];
            function ready(fn) {
                if (!isReady) {
                    if (!doc.body) {
                        return defer(ready);
                    }
                    isReady = true;
                    while (fn = callbacks.shift()) {
                        defer(fn);
                    }
                }
            }
            function completed(event) {
                if (w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE) {
                    detach();
                    ready();
                }
            }
            function detach() {
                if (w3c) {
                    doc[REMOVEEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
                    win[REMOVEEVENTLISTENER](LOAD, completed, FALSE);
                } else {
                    doc[DETACHEVENT](ONREADYSTATECHANGE, completed);
                    win[DETACHEVENT](ONLOAD, completed);
                }
            }
            function defer(fn, wait) {
                setTimeout(fn, +wait >= 0 ? wait : 1);
            }
            if (doc[READYSTATE] === COMPLETE) {
                defer(ready);
            } else if (w3c) {
                doc[ADDEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
                win[ADDEVENTLISTENER](LOAD, completed, FALSE);
            } else {
                doc[ATTACHEVENT](ONREADYSTATECHANGE, completed);
                win[ATTACHEVENT](ONLOAD, completed);
                try {
                    _top = win.frameElement == null && docElem;
                } catch (e) {}
                if (_top && _top.doScroll) {
                    (function doScrollCheck() {
                        if (!isReady) {
                            try {
                                _top.doScroll("left");
                            } catch (e) {
                                return defer(doScrollCheck, 50);
                            }
                            detach();
                            ready();
                        }
                    })();
                }
            }
            function onDomReady(fn) {
                isReady ? defer(fn) : callbacks.push(fn);
            }
            onDomReady.version = "1.4.0";
            onDomReady.isReady = function() {
                return isReady;
            };
            return onDomReady;
        }
        module.exports = typeof window !== "undefined" && _onDomReady(window);
    }, function(module, exports, __webpack_require__) {
        var encode = encodeURIComponent;
        var decode = decodeURIComponent;
        var trim = __webpack_require__(4);
        var type = __webpack_require__(5);
        var arrayRegex = /(\w+)\[(\d+)\]/;
        var objectRegex = /\w+\.\w+/;
        exports.parse = function(str) {
            if ("string" !== typeof str) return {};
            str = trim(str);
            if ("" === str) return {};
            if ("?" === str.charAt(0)) str = str.slice(1);
            var obj = {};
            var pairs = str.split("&");
            for (var i = 0; i < pairs.length; i++) {
                var parts = pairs[i].split("=");
                var key = decode(parts[0]);
                var m, ctx, prop;
                if (m = arrayRegex.exec(key)) {
                    obj[m[1]] = obj[m[1]] || [];
                    obj[m[1]][m[2]] = decode(parts[1]);
                    continue;
                }
                if (m = objectRegex.test(key)) {
                    m = key.split(".");
                    ctx = obj;
                    while (m.length) {
                        prop = m.shift();
                        if (!prop.length) continue;
                        if (!ctx[prop]) {
                            ctx[prop] = {};
                        } else if (ctx[prop] && typeof ctx[prop] !== "object") {
                            break;
                        }
                        if (!m.length) {
                            ctx[prop] = decode(parts[1]);
                        }
                        ctx = ctx[prop];
                    }
                    continue;
                }
                obj[parts[0]] = null == parts[1] ? "" : decode(parts[1]);
            }
            return obj;
        };
        exports.stringify = function(obj) {
            if (!obj) return "";
            var pairs = [];
            for (var key in obj) {
                var value = obj[key];
                if ("array" == type(value)) {
                    for (var i = 0; i < value.length; ++i) {
                        pairs.push(encode(key + "[" + i + "]") + "=" + encode(value[i]));
                    }
                    continue;
                }
                pairs.push(encode(key) + "=" + encode(obj[key]));
            }
            return pairs.join("&");
        };
    }, function(module, exports) {
        exports = module.exports = trim;
        function trim(str) {
            return str.replace(/^\s*|\s*$/g, "");
        }
        exports.left = function(str) {
            return str.replace(/^\s*/, "");
        };
        exports.right = function(str) {
            return str.replace(/\s*$/, "");
        };
    }, function(module, exports) {
        var toString = Object.prototype.toString;
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";

              case "[object Error]":
                return "error";
            }
            if (val === null) return "null";
            if (val === undefined) return "undefined";
            if (val !== val) return "nan";
            if (val && val.nodeType === 1) return "element";
            if (isBuffer(val)) return "buffer";
            val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
            return typeof val;
        };
        function isBuffer(obj) {
            return !!(obj != null && (obj._isBuffer || obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj)));
        }
    }, function(module, exports) {
        var SceneGraph = function(sceneProperties) {
            var nodeCount = 1;
            function merge(parent, child) {
                for (var prop in child) {
                    parent[prop] = child[prop];
                }
                return parent;
            }
            var SceneNode = function(name) {
                nodeCount++;
                this.parent = null;
                this.children = {};
                this.id = nodeCount;
                this.name = "n" + nodeCount;
                if (typeof name !== "undefined") {
                    this.name = name;
                }
                this.x = this.y = this.z = 0;
                this.width = this.height = 0;
            };
            SceneNode.prototype.resize = function(width, height) {
                if (width != null) {
                    this.width = width;
                }
                if (height != null) {
                    this.height = height;
                }
            };
            SceneNode.prototype.moveTo = function(x, y, z) {
                this.x = x != null ? x : this.x;
                this.y = y != null ? y : this.y;
                this.z = z != null ? z : this.z;
            };
            SceneNode.prototype.add = function(child) {
                var name = child.name;
                if (typeof this.children[name] === "undefined") {
                    this.children[name] = child;
                    child.parent = this;
                } else {
                    throw "SceneGraph: child already exists: " + name;
                }
            };
            var RootNode = function() {
                SceneNode.call(this, "root");
                this.properties = sceneProperties;
            };
            RootNode.prototype = new SceneNode();
            var Shape = function(name, props) {
                SceneNode.call(this, name);
                this.properties = {
                    fill: "#000000"
                };
                if (typeof props !== "undefined") {
                    merge(this.properties, props);
                } else if (typeof name !== "undefined" && typeof name !== "string") {
                    throw "SceneGraph: invalid node name";
                }
            };
            Shape.prototype = new SceneNode();
            var Group = function() {
                Shape.apply(this, arguments);
                this.type = "group";
            };
            Group.prototype = new Shape();
            var Rect = function() {
                Shape.apply(this, arguments);
                this.type = "rect";
            };
            Rect.prototype = new Shape();
            var Text = function(text) {
                Shape.call(this);
                this.type = "text";
                this.properties.text = text;
            };
            Text.prototype = new Shape();
            var root = new RootNode();
            this.Shape = {
                Rect: Rect,
                Text: Text,
                Group: Group
            };
            this.root = root;
            return this;
        };
        module.exports = SceneGraph;
    }, function(module, exports) {
        (function(global) {
            exports.extend = function(a, b) {
                var c = {};
                for (var x in a) {
                    if (a.hasOwnProperty(x)) {
                        c[x] = a[x];
                    }
                }
                if (b != null) {
                    for (var y in b) {
                        if (b.hasOwnProperty(y)) {
                            c[y] = b[y];
                        }
                    }
                }
                return c;
            };
            exports.cssProps = function(props) {
                var ret = [];
                for (var p in props) {
                    if (props.hasOwnProperty(p)) {
                        ret.push(p + ":" + props[p]);
                    }
                }
                return ret.join(";");
            };
            exports.encodeHtmlEntity = function(str) {
                var buf = [];
                var charCode = 0;
                for (var i = str.length - 1; i >= 0; i--) {
                    charCode = str.charCodeAt(i);
                    if (charCode > 128) {
                        buf.unshift([ "&#", charCode, ";" ].join(""));
                    } else {
                        buf.unshift(str[i]);
                    }
                }
                return buf.join("");
            };
            exports.imageExists = function(src, callback) {
                var image = new Image();
                image.onerror = function() {
                    callback.call(this, false);
                };
                image.onload = function() {
                    callback.call(this, true);
                };
                image.src = src;
            };
            exports.decodeHtmlEntity = function(str) {
                return str.replace(/&#(\d+);/g, function(match, dec) {
                    return String.fromCharCode(dec);
                });
            };
            exports.dimensionCheck = function(el) {
                var dimensions = {
                    height: el.clientHeight,
                    width: el.clientWidth
                };
                if (dimensions.height && dimensions.width) {
                    return dimensions;
                } else {
                    return false;
                }
            };
            exports.truthy = function(val) {
                if (typeof val === "string") {
                    return val === "true" || val === "yes" || val === "1" || val === "on" || val === "✓";
                }
                return !!val;
            };
            exports.parseColor = function(val) {
                var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;
                var rgbre = /^rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
                var rgbare = /^rgba\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0\.\d{1,}|1)\)$/;
                var match = val.match(hexre);
                var retval;
                if (match !== null) {
                    retval = match[1] || match[2];
                    if (retval[0] !== "#") {
                        return "#" + retval;
                    } else {
                        return retval;
                    }
                }
                match = val.match(rgbre);
                if (match !== null) {
                    retval = "rgb(" + match.slice(1).join(",") + ")";
                    return retval;
                }
                match = val.match(rgbare);
                if (match !== null) {
                    retval = "rgba(" + match.slice(1).join(",") + ")";
                    return retval;
                }
                return null;
            };
            exports.canvasRatio = function() {
                var devicePixelRatio = 1;
                var backingStoreRatio = 1;
                if (global.document) {
                    var canvas = global.document.createElement("canvas");
                    if (canvas.getContext) {
                        var ctx = canvas.getContext("2d");
                        devicePixelRatio = global.devicePixelRatio || 1;
                        backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                    }
                }
                return devicePixelRatio / backingStoreRatio;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            var DOM = __webpack_require__(9);
            var SVG_NS = "http://www.w3.org/2000/svg";
            var NODE_TYPE_COMMENT = 8;
            exports.initSVG = function(svg, width, height) {
                var defs, style, initialize = false;
                if (svg && svg.querySelector) {
                    style = svg.querySelector("style");
                    if (style === null) {
                        initialize = true;
                    }
                } else {
                    svg = DOM.newEl("svg", SVG_NS);
                    initialize = true;
                }
                if (initialize) {
                    defs = DOM.newEl("defs", SVG_NS);
                    style = DOM.newEl("style", SVG_NS);
                    DOM.setAttr(style, {
                        type: "text/css"
                    });
                    defs.appendChild(style);
                    svg.appendChild(defs);
                }
                if (svg.webkitMatchesSelector) {
                    svg.setAttribute("xmlns", SVG_NS);
                }
                for (var i = 0; i < svg.childNodes.length; i++) {
                    if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {
                        svg.removeChild(svg.childNodes[i]);
                    }
                }
                while (style.childNodes.length) {
                    style.removeChild(style.childNodes[0]);
                }
                DOM.setAttr(svg, {
                    width: width,
                    height: height,
                    viewBox: "0 0 " + width + " " + height,
                    preserveAspectRatio: "none"
                });
                return svg;
            };
            exports.svgStringToDataURI = function() {
                var rawPrefix = "data:image/svg+xml;charset=UTF-8,";
                var base64Prefix = "data:image/svg+xml;charset=UTF-8;base64,";
                return function(svgString, base64) {
                    if (base64) {
                        return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));
                    } else {
                        return rawPrefix + encodeURIComponent(svgString);
                    }
                };
            }();
            exports.serializeSVG = function(svg, engineSettings) {
                if (!global.XMLSerializer) return;
                var serializer = new XMLSerializer();
                var svgCSS = "";
                var stylesheets = engineSettings.stylesheets;
                if (engineSettings.svgXMLStylesheet) {
                    var xml = DOM.createXML();
                    for (var i = stylesheets.length - 1; i >= 0; i--) {
                        var csspi = xml.createProcessingInstruction("xml-stylesheet", 'href="' + stylesheets[i] + '" rel="stylesheet"');
                        xml.insertBefore(csspi, xml.firstChild);
                    }
                    xml.removeChild(xml.documentElement);
                    svgCSS = serializer.serializeToString(xml);
                }
                var svgText = serializer.serializeToString(svg);
                svgText = svgText.replace(/\&amp;(\#[0-9]{2,}\;)/g, "&$1");
                return svgCSS + svgText;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        (function(global) {
            exports.newEl = function(tag, namespace) {
                if (!global.document) return;
                if (namespace == null) {
                    return global.document.createElement(tag);
                } else {
                    return global.document.createElementNS(namespace, tag);
                }
            };
            exports.setAttr = function(el, attrs) {
                for (var a in attrs) {
                    el.setAttribute(a, attrs[a]);
                }
            };
            exports.createXML = function() {
                if (!global.DOMParser) return;
                return new DOMParser().parseFromString("<xml />", "application/xml");
            };
            exports.getNodeArray = function(val) {
                var retval = null;
                if (typeof val == "string") {
                    retval = document.querySelectorAll(val);
                } else if (global.NodeList && val instanceof global.NodeList) {
                    retval = val;
                } else if (global.Node && val instanceof global.Node) {
                    retval = [ val ];
                } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {
                    retval = val;
                } else if (val instanceof Array) {
                    retval = val;
                } else if (val === null) {
                    retval = [];
                }
                retval = Array.prototype.slice.call(retval);
                return retval;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        var Color = function(color, options) {
            if (typeof color !== "string") return;
            this.original = color;
            if (color.charAt(0) === "#") {
                color = color.slice(1);
            }
            if (/[^a-f0-9]+/i.test(color)) return;
            if (color.length === 3) {
                color = color.replace(/./g, "$&$&");
            }
            if (color.length !== 6) return;
            this.alpha = 1;
            if (options && options.alpha) {
                this.alpha = options.alpha;
            }
            this.set(parseInt(color, 16));
        };
        Color.rgb2hex = function(r, g, b) {
            function format(decimal) {
                var hex = (decimal | 0).toString(16);
                if (decimal < 16) {
                    hex = "0" + hex;
                }
                return hex;
            }
            return [ r, g, b ].map(format).join("");
        };
        Color.hsl2rgb = function(h, s, l) {
            var H = h / 60;
            var C = (1 - Math.abs(2 * l - 1)) * s;
            var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));
            var m = l - C / 2;
            var r = 0, g = 0, b = 0;
            if (H >= 0 && H < 1) {
                r = C;
                g = X;
            } else if (H >= 1 && H < 2) {
                r = X;
                g = C;
            } else if (H >= 2 && H < 3) {
                g = C;
                b = X;
            } else if (H >= 3 && H < 4) {
                g = X;
                b = C;
            } else if (H >= 4 && H < 5) {
                r = X;
                b = C;
            } else if (H >= 5 && H < 6) {
                r = C;
                b = X;
            }
            r += m;
            g += m;
            b += m;
            r = parseInt(r * 255);
            g = parseInt(g * 255);
            b = parseInt(b * 255);
            return [ r, g, b ];
        };
        Color.prototype.set = function(val) {
            this.raw = val;
            var r = (this.raw & 16711680) >> 16;
            var g = (this.raw & 65280) >> 8;
            var b = this.raw & 255;
            var y = .2126 * r + .7152 * g + .0722 * b;
            var u = -.09991 * r - .33609 * g + .436 * b;
            var v = .615 * r - .55861 * g - .05639 * b;
            this.rgb = {
                r: r,
                g: g,
                b: b
            };
            this.yuv = {
                y: y,
                u: u,
                v: v
            };
            return this;
        };
        Color.prototype.lighten = function(multiplier) {
            var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);
            var bm = 255 * cm | 0;
            var cr = Math.min(255, Math.max(0, this.rgb.r + bm));
            var cg = Math.min(255, Math.max(0, this.rgb.g + bm));
            var cb = Math.min(255, Math.max(0, this.rgb.b + bm));
            var hex = Color.rgb2hex(cr, cg, cb);
            return new Color(hex);
        };
        Color.prototype.toHex = function(addHash) {
            return (addHash ? "#" : "") + this.raw.toString(16);
        };
        Color.prototype.lighterThan = function(color) {
            if (!(color instanceof Color)) {
                color = new Color(color);
            }
            return this.yuv.y > color.yuv.y;
        };
        Color.prototype.blendAlpha = function(color) {
            if (!(color instanceof Color)) {
                color = new Color(color);
            }
            var Ca = color;
            var Cb = this;
            var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;
            var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;
            var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;
            return new Color(Color.rgb2hex(r, g, b));
        };
        module.exports = Color;
    }, function(module, exports) {
        module.exports = {
            version: "2.9.4",
            svg_ns: "http://www.w3.org/2000/svg"
        };
    }, function(module, exports, __webpack_require__) {
        var shaven = __webpack_require__(13);
        var SVG = __webpack_require__(8);
        var constants = __webpack_require__(11);
        var utils = __webpack_require__(7);
        var SVG_NS = constants.svg_ns;
        var templates = {
            element: function(options) {
                var tag = options.tag;
                var content = options.content || "";
                delete options.tag;
                delete options.content;
                return [ tag, content, options ];
            }
        };
        function convertShape(shape, tag) {
            return templates.element({
                tag: tag,
                width: shape.width,
                height: shape.height,
                fill: shape.properties.fill
            });
        }
        function textCss(properties) {
            return utils.cssProps({
                fill: properties.fill,
                "font-weight": properties.font.weight,
                "font-family": properties.font.family + ", monospace",
                "font-size": properties.font.size + properties.font.units
            });
        }
        function outlinePath(bgWidth, bgHeight, outlineWidth) {
            var outlineOffsetWidth = outlineWidth / 2;
            return [ "M", outlineOffsetWidth, outlineOffsetWidth, "H", bgWidth - outlineOffsetWidth, "V", bgHeight - outlineOffsetWidth, "H", outlineOffsetWidth, "V", 0, "M", 0, outlineOffsetWidth, "L", bgWidth, bgHeight - outlineOffsetWidth, "M", 0, bgHeight - outlineOffsetWidth, "L", bgWidth, outlineOffsetWidth ].join(" ");
        }
        module.exports = function(sceneGraph, renderSettings) {
            var engineSettings = renderSettings.engineSettings;
            var stylesheets = engineSettings.stylesheets;
            var stylesheetXml = stylesheets.map(function(stylesheet) {
                return '<?xml-stylesheet rel="stylesheet" href="' + stylesheet + '"?>';
            }).join("\n");
            var holderId = "holder_" + Number(new Date()).toString(16);
            var root = sceneGraph.root;
            var textGroup = root.children.holderTextGroup;
            var css = "#" + holderId + " text { " + textCss(textGroup.properties) + " } ";
            textGroup.y += textGroup.textPositionData.boundingBox.height * .8;
            var wordTags = [];
            Object.keys(textGroup.children).forEach(function(lineKey) {
                var line = textGroup.children[lineKey];
                Object.keys(line.children).forEach(function(wordKey) {
                    var word = line.children[wordKey];
                    var x = textGroup.x + line.x + word.x;
                    var y = textGroup.y + line.y + word.y;
                    var wordTag = templates.element({
                        tag: "text",
                        content: word.properties.text,
                        x: x,
                        y: y
                    });
                    wordTags.push(wordTag);
                });
            });
            var text = templates.element({
                tag: "g",
                content: wordTags
            });
            var outline = null;
            if (root.children.holderBg.properties.outline) {
                var outlineProperties = root.children.holderBg.properties.outline;
                outline = templates.element({
                    tag: "path",
                    d: outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),
                    "stroke-width": outlineProperties.width,
                    stroke: outlineProperties.fill,
                    fill: "none"
                });
            }
            var bg = convertShape(root.children.holderBg, "rect");
            var sceneContent = [];
            sceneContent.push(bg);
            if (outlineProperties) {
                sceneContent.push(outline);
            }
            sceneContent.push(text);
            var scene = templates.element({
                tag: "g",
                id: holderId,
                content: sceneContent
            });
            var style = templates.element({
                tag: "style",
                content: css,
                type: "text/css"
            });
            var defs = templates.element({
                tag: "defs",
                content: style
            });
            var svg = templates.element({
                tag: "svg",
                content: [ defs, scene ],
                width: root.properties.width,
                height: root.properties.height,
                xmlns: SVG_NS,
                viewBox: [ 0, 0, root.properties.width, root.properties.height ].join(" "),
                preserveAspectRatio: "none"
            });
            var output = shaven(svg);
            output = stylesheetXml + output[0];
            var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === "background");
            return svgString;
        };
    }, function(module, exports, __webpack_require__) {
        var escape = __webpack_require__(14);
        module.exports = function shaven(array, namespace, returnObject) {
            "use strict";
            var i = 1;
            var doesEscape = true;
            var HTMLString;
            var attributeKey;
            var callback;
            var key;
            returnObject = returnObject || {};
            function createElement(sugarString) {
                var tags = sugarString.match(/^[\w-]+/);
                var element = {
                    tag: tags ? tags[0] : "div",
                    attr: {},
                    children: []
                };
                var id = sugarString.match(/#([\w-]+)/);
                var reference = sugarString.match(/\$([\w-]+)/);
                var classNames = sugarString.match(/\.[\w-]+/g);
                if (id) {
                    element.attr.id = id[1];
                    returnObject[id[1]] = element;
                }
                if (reference) returnObject[reference[1]] = element;
                if (classNames) element.attr.class = classNames.join(" ").replace(/\./g, "");
                if (sugarString.match(/&$/g)) doesEscape = false;
                return element;
            }
            function replacer(key, value) {
                if (value === null || value === false || value === undefined) return;
                if (typeof value !== "string" && typeof value !== "object") return String(value);
                return value;
            }
            function escapeAttribute(string) {
                return string || string === 0 ? String(string).replace(/&/g, "&amp;").replace(/"/g, "&quot;") : "";
            }
            function escapeHTML(string) {
                return String(string).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }
            if (typeof array[0] === "string") array[0] = createElement(array[0]); else if (Array.isArray(array[0])) i = 0; else throw new Error("First element of array must be a string, " + "or an array and not " + JSON.stringify(array[0]));
            for (;i < array.length; i++) {
                if (array[i] === false || array[i] === null) {
                    array[0] = false;
                    break;
                } else if (array[i] === undefined || array[i] === true) {
                    continue;
                } else if (typeof array[i] === "string") {
                    if (doesEscape) array[i] = escapeHTML(array[i]);
                    array[0].children.push(array[i]);
                } else if (typeof array[i] === "number") {
                    array[0].children.push(array[i]);
                } else if (Array.isArray(array[i])) {
                    if (Array.isArray(array[i][0])) {
                        array[i].reverse().forEach(function(subArray) {
                            array.splice(i + 1, 0, subArray);
                        });
                        if (i !== 0) continue;
                        i++;
                    }
                    shaven(array[i], namespace, returnObject);
                    if (array[i][0]) array[0].children.push(array[i][0]);
                } else if (typeof array[i] === "function") callback = array[i]; else if (typeof array[i] === "object") {
                    for (attributeKey in array[i]) if (array[i].hasOwnProperty(attributeKey)) if (array[i][attributeKey] !== null && array[i][attributeKey] !== false) if (attributeKey === "style" && typeof array[i][attributeKey] === "object") array[0].attr[attributeKey] = JSON.stringify(array[i][attributeKey], replacer).slice(2, -2).replace(/","/g, ";").replace(/":"/g, ":").replace(/\\"/g, "'"); else array[0].attr[attributeKey] = array[i][attributeKey];
                } else throw new TypeError('"' + array[i] + '" is not allowed as a value.');
            }
            if (array[0] !== false) {
                HTMLString = "<" + array[0].tag;
                for (key in array[0].attr) if (array[0].attr.hasOwnProperty(key)) HTMLString += " " + key + '="' + escapeAttribute(array[0].attr[key]) + '"';
                HTMLString += ">";
                array[0].children.forEach(function(child) {
                    HTMLString += child;
                });
                HTMLString += "</" + array[0].tag + ">";
                array[0] = HTMLString;
            }
            returnObject[0] = array[0];
            if (callback) callback(array[0]);
            return returnObject;
        };
    }, function(module, exports) {
        "use strict";
        var matchHtmlRegExp = /["'&<>]/;
        module.exports = escapeHtml;
        function escapeHtml(string) {
            var str = "" + string;
            var match = matchHtmlRegExp.exec(str);
            if (!match) {
                return str;
            }
            var escape;
            var html = "";
            var index = 0;
            var lastIndex = 0;
            for (index = match.index; index < str.length; index++) {
                switch (str.charCodeAt(index)) {
                  case 34:
                    escape = "&quot;";
                    break;

                  case 38:
                    escape = "&amp;";
                    break;

                  case 39:
                    escape = "&#39;";
                    break;

                  case 60:
                    escape = "&lt;";
                    break;

                  case 62:
                    escape = "&gt;";
                    break;

                  default:
                    continue;
                }
                if (lastIndex !== index) {
                    html += str.substring(lastIndex, index);
                }
                lastIndex = index + 1;
                html += escape;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
    }, function(module, exports, __webpack_require__) {
        var DOM = __webpack_require__(9);
        var utils = __webpack_require__(7);
        module.exports = function() {
            var canvas = DOM.newEl("canvas");
            var ctx = null;
            return function(sceneGraph) {
                if (ctx == null) {
                    ctx = canvas.getContext("2d");
                }
                var dpr = utils.canvasRatio();
                var root = sceneGraph.root;
                canvas.width = dpr * root.properties.width;
                canvas.height = dpr * root.properties.height;
                ctx.textBaseline = "middle";
                var bg = root.children.holderBg;
                var bgWidth = dpr * bg.width;
                var bgHeight = dpr * bg.height;
                var outlineWidth = 2;
                var outlineOffsetWidth = outlineWidth / 2;
                ctx.fillStyle = bg.properties.fill;
                ctx.fillRect(0, 0, bgWidth, bgHeight);
                if (bg.properties.outline) {
                    ctx.strokeStyle = bg.properties.outline.fill;
                    ctx.lineWidth = bg.properties.outline.width;
                    ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);
                    ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);
                    ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);
                    ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);
                    ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);
                    ctx.moveTo(0, outlineOffsetWidth);
                    ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);
                    ctx.moveTo(0, bgHeight - outlineOffsetWidth);
                    ctx.lineTo(bgWidth, outlineOffsetWidth);
                    ctx.stroke();
                }
                var textGroup = root.children.holderTextGroup;
                ctx.font = textGroup.properties.font.weight + " " + dpr * textGroup.properties.font.size + textGroup.properties.font.units + " " + textGroup.properties.font.family + ", monospace";
                ctx.fillStyle = textGroup.properties.fill;
                for (var lineKey in textGroup.children) {
                    var line = textGroup.children[lineKey];
                    for (var wordKey in line.children) {
                        var word = line.children[wordKey];
                        var x = dpr * (textGroup.x + line.x + word.x);
                        var y = dpr * (textGroup.y + line.y + word.y + textGroup.properties.leading / 2);
                        ctx.fillText(word.properties.text, x, y);
                    }
                }
                return canvas.toDataURL("image/png");
            };
        }();
    } ]);
});

(function(ctx, isMeteorPackage) {
    if (isMeteorPackage) {
        Holder = ctx.Holder;
    }
})(this, typeof Meteor !== "undefined" && typeof Package !== "undefined");

(function($) {
    $.loadingButton = function(element, options) {
        var settings = $.extend({}, $.loadingButton.defaults, options), btn = $(element);
        function setLoadingState() {
            if (!settings.condition()) {
                return;
            }
            console.log(settings);
            if (settings.loadingClass) {
                btn.addClass(settings.loadingClass);
            }
            var isInput = btn.is("input"), btnText = isInput ? btn.val() : btn.text(), loadingText = btn.data("loading-text");
            if (loadingText) {
                btn.data("default-text", btnText);
                if (isInput) {
                    btn.val(loadingText);
                } else {
                    btn.text(loadingText);
                }
            }
            if (settings.disable) {
                setTimeout(function() {
                    btn.prop("disabled", true);
                }, 1);
            }
        }
        function restoreButton() {
            if (settings.loadingClass) {
                btn.removeClass(settings.loadingClass);
            }
            if (settings.disable) {
                btn.prop("disabled", false);
            }
            var isInput = btn.is("input"), defaultText = btn.data("default-text");
            if (defaultText) {
                if (isInput) {
                    btn.val(defaultText);
                } else {
                    btn.text(defaultText);
                }
            }
        }
        if (settings.loadingText) {
            btn.data("loading-text", settings.loadingText);
        }
        btn.click(function() {
            setLoadingState();
        }).on("reset", function() {
            restoreButton();
        });
    };
    $.fn.loadingButton = function(options) {
        return $(this).each(function() {
            new $.loadingButton(this, options);
        });
    };
    $.loadingButton.defaults = {
        condition: function() {
            return true;
        },
        disable: true,
        loadingClass: null,
        loadingText: null
    };
    $(function() {
        $("[data-loading-button]").loadingButton();
    });
})(jQuery);

(function($) {
    $.fn.maxLength = function() {
        var testElement = document.createElement("textarea"), supportsMaxlength = "maxLength" in testElement, el = $(this);
        if (!supportsMaxlength) {
            el.keyup(function() {
                var $this = $(this), max = parseInt($this.attr("maxlength")), text = $this.val();
                if (text.length > max) {
                    $this.val(text.substr(0, max));
                }
            });
        }
        return el;
    };
})(jQuery);

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    var debugMode = false;
    var isOperaMini = Object.prototype.toString.call(window.operamini) === "[object OperaMini]";
    var isInputSupported = "placeholder" in document.createElement("input") && !isOperaMini && !debugMode;
    var isTextareaSupported = "placeholder" in document.createElement("textarea") && !isOperaMini && !debugMode;
    var valHooks = $.valHooks;
    var propHooks = $.propHooks;
    var hooks;
    var placeholder;
    var settings = {};
    if (isInputSupported && isTextareaSupported) {
        placeholder = $.fn.placeholder = function() {
            return this;
        };
        placeholder.input = true;
        placeholder.textarea = true;
    } else {
        placeholder = $.fn.placeholder = function(options) {
            var defaults = {
                customClass: "placeholder"
            };
            settings = $.extend({}, defaults, options);
            return this.filter((isInputSupported ? "textarea" : ":input") + "[" + (debugMode ? "placeholder-x" : "placeholder") + "]").not("." + settings.customClass).not(":radio, :checkbox, [type=hidden]").bind({
                "focus.placeholder": clearPlaceholder,
                "blur.placeholder": setPlaceholder
            }).data("placeholder-enabled", true).trigger("blur.placeholder");
        };
        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;
        hooks = {
            get: function(element) {
                var $element = $(element);
                var $passwordInput = $element.data("placeholder-password");
                if ($passwordInput) {
                    return $passwordInput[0].value;
                }
                return $element.data("placeholder-enabled") && $element.hasClass(settings.customClass) ? "" : element.value;
            },
            set: function(element, value) {
                var $element = $(element);
                var $replacement;
                var $passwordInput;
                if (value !== "") {
                    $replacement = $element.data("placeholder-textinput");
                    $passwordInput = $element.data("placeholder-password");
                    if ($replacement) {
                        clearPlaceholder.call($replacement[0], true, value) || (element.value = value);
                        $replacement[0].value = value;
                    } else if ($passwordInput) {
                        clearPlaceholder.call(element, true, value) || ($passwordInput[0].value = value);
                        element.value = value;
                    }
                }
                if (!$element.data("placeholder-enabled")) {
                    element.value = value;
                    return $element;
                }
                if (value === "") {
                    element.value = value;
                    if (element != safeActiveElement()) {
                        setPlaceholder.call(element);
                    }
                } else {
                    if ($element.hasClass(settings.customClass)) {
                        clearPlaceholder.call(element);
                    }
                    element.value = value;
                }
                return $element;
            }
        };
        if (!isInputSupported) {
            valHooks.input = hooks;
            propHooks.value = hooks;
        }
        if (!isTextareaSupported) {
            valHooks.textarea = hooks;
            propHooks.value = hooks;
        }
        $(function() {
            $(document).delegate("form", "submit.placeholder", function() {
                var $inputs = $("." + settings.customClass, this).each(function() {
                    clearPlaceholder.call(this, true, "");
                });
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });
        $(window).bind("beforeunload.placeholder", function() {
            var clearPlaceholders = true;
            try {
                if (document.activeElement.toString() === "javascript:void(0)") {
                    clearPlaceholders = false;
                }
            } catch (exception) {}
            if (clearPlaceholders) {
                $("." + settings.customClass).each(function() {
                    this.value = "";
                });
            }
        });
    }
    function args(elem) {
        var newAttrs = {};
        var rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }
    function clearPlaceholder(event, value) {
        var input = this;
        var $input = $(this);
        if (input.value === $input.attr(debugMode ? "placeholder-x" : "placeholder") && $input.hasClass(settings.customClass)) {
            input.value = "";
            $input.removeClass(settings.customClass);
            if ($input.data("placeholder-password")) {
                $input = $input.hide().nextAll('input[type="password"]:first').show().attr("id", $input.removeAttr("id").data("placeholder-id"));
                if (event === true) {
                    $input[0].value = value;
                    return value;
                }
                $input.focus();
            } else {
                input == safeActiveElement() && input.select();
            }
        }
    }
    function setPlaceholder(event) {
        var $replacement;
        var input = this;
        var $input = $(this);
        var id = input.id;
        if (event && event.type === "blur" && $input.hasClass(settings.customClass)) {
            return;
        }
        if (input.value === "") {
            if (input.type === "password") {
                if (!$input.data("placeholder-textinput")) {
                    try {
                        $replacement = $input.clone().prop({
                            type: "text"
                        });
                    } catch (e) {
                        $replacement = $("<input>").attr($.extend(args(this), {
                            type: "text"
                        }));
                    }
                    $replacement.removeAttr("name").data({
                        "placeholder-enabled": true,
                        "placeholder-password": $input,
                        "placeholder-id": id
                    }).bind("focus.placeholder", clearPlaceholder);
                    $input.data({
                        "placeholder-textinput": $replacement,
                        "placeholder-id": id
                    }).before($replacement);
                }
                input.value = "";
                $input = $input.removeAttr("id").hide().prevAll('input[type="text"]:first').attr("id", $input.data("placeholder-id")).show();
            } else {
                var $passwordInput = $input.data("placeholder-password");
                if ($passwordInput) {
                    $passwordInput[0].value = "";
                    $input.attr("id", $input.data("placeholder-id")).show().nextAll('input[type="password"]:last').hide().removeAttr("id");
                }
            }
            $input.addClass(settings.customClass);
            $input[0].value = $input.attr(debugMode ? "placeholder-x" : "placeholder");
        } else {
            $input.removeClass(settings.customClass);
        }
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (exception) {}
    }
});

(function(f) {
    "use strict";
    "function" === typeof define && define.amd ? define([ "jquery" ], f) : "undefined" !== typeof module && module.exports ? module.exports = f(require("jquery")) : f(jQuery);
})(function($) {
    "use strict";
    function n(a) {
        return !a.nodeName || -1 !== $.inArray(a.nodeName.toLowerCase(), [ "iframe", "#document", "html", "body" ]);
    }
    function h(a) {
        return $.isFunction(a) || $.isPlainObject(a) ? a : {
            top: a,
            left: a
        };
    }
    var p = $.scrollTo = function(a, d, b) {
        return $(window).scrollTo(a, d, b);
    };
    p.defaults = {
        axis: "xy",
        duration: 0,
        limit: !0
    };
    $.fn.scrollTo = function(a, d, b) {
        "object" === typeof d && (b = d, d = 0);
        "function" === typeof b && (b = {
            onAfter: b
        });
        "max" === a && (a = 9e9);
        b = $.extend({}, p.defaults, b);
        d = d || b.duration;
        var u = b.queue && 1 < b.axis.length;
        u && (d /= 2);
        b.offset = h(b.offset);
        b.over = h(b.over);
        return this.each(function() {
            function k(a) {
                var k = $.extend({}, b, {
                    queue: !0,
                    duration: d,
                    complete: a && function() {
                        a.call(q, e, b);
                    }
                });
                r.animate(f, k);
            }
            if (null !== a) {
                var l = n(this), q = l ? this.contentWindow || window : this, r = $(q), e = a, f = {}, t;
                switch (typeof e) {
                  case "number":
                  case "string":
                    if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(e)) {
                        e = h(e);
                        break;
                    }
                    e = l ? $(e) : $(e, q);

                  case "object":
                    if (e.length === 0) return;
                    if (e.is || e.style) t = (e = $(e)).offset();
                }
                var v = $.isFunction(b.offset) && b.offset(q, e) || b.offset;
                $.each(b.axis.split(""), function(a, c) {
                    var d = "x" === c ? "Left" : "Top", m = d.toLowerCase(), g = "scroll" + d, h = r[g](), n = p.max(q, c);
                    t ? (f[g] = t[m] + (l ? 0 : h - r.offset()[m]), b.margin && (f[g] -= parseInt(e.css("margin" + d), 10) || 0, 
                    f[g] -= parseInt(e.css("border" + d + "Width"), 10) || 0), f[g] += v[m] || 0, b.over[m] && (f[g] += e["x" === c ? "width" : "height"]() * b.over[m])) : (d = e[m], 
                    f[g] = d.slice && "%" === d.slice(-1) ? parseFloat(d) / 100 * n : d);
                    b.limit && /^\d+$/.test(f[g]) && (f[g] = 0 >= f[g] ? 0 : Math.min(f[g], n));
                    !a && 1 < b.axis.length && (h === f[g] ? f = {} : u && (k(b.onAfterFirst), f = {}));
                });
                k(b.onAfter);
            }
        });
    };
    p.max = function(a, d) {
        var b = "x" === d ? "Width" : "Height", h = "scroll" + b;
        if (!n(a)) return a[h] - $(a)[b.toLowerCase()]();
        var b = "client" + b, k = a.ownerDocument || a.document, l = k.documentElement, k = k.body;
        return Math.max(l[h], k[h]) - Math.min(l[b], k[b]);
    };
    $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
        get: function(a) {
            return $(a.elem)[a.prop]();
        },
        set: function(a) {
            var d = this.get(a);
            if (a.options.interrupt && a._last && a._last !== d) return $(a.elem).stop();
            var b = Math.round(a.now);
            d !== b && ($(a.elem)[a.prop](b), a._last = this.get(a));
        }
    };
    return p;
});

$(document).ready(function() {});

$(window).ready(function(e) {});